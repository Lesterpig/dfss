// Code generated by protoc-gen-go.
// source: dfss/dfssp/api/platform.proto
// DO NOT EDIT!

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	dfss/dfssp/api/platform.proto

It has these top-level messages:
	RegisterRequest
	ErrorCode
	AuthRequest
	RegisteredUser
	Empty
	PostContractRequest
	GetContractRequest
	Contract
	JoinSignatureRequest
	UserConnected
	User
	ReadySignRequest
	LaunchSignature
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type ErrorCode_Code int32

const (
	// / the error code for a successful request
	ErrorCode_SUCCESS ErrorCode_Code = 0
	// / the error code for an invalid argument
	ErrorCode_INVARG ErrorCode_Code = 1
	// / the error code for a bad authentication
	ErrorCode_BADAUTH ErrorCode_Code = 2
	// / the error code for a success state containing a specific warning message
	ErrorCode_WARNING ErrorCode_Code = 3
	// / the error code for an internal server error
	ErrorCode_INTERR ErrorCode_Code = -1
	// / the error code for a timeout or unreacheable target
	ErrorCode_TIMEOUT ErrorCode_Code = -2
)

var ErrorCode_Code_name = map[int32]string{
	0:  "SUCCESS",
	1:  "INVARG",
	2:  "BADAUTH",
	3:  "WARNING",
	-1: "INTERR",
	-2: "TIMEOUT",
}
var ErrorCode_Code_value = map[string]int32{
	"SUCCESS": 0,
	"INVARG":  1,
	"BADAUTH": 2,
	"WARNING": 3,
	"INTERR":  -1,
	"TIMEOUT": -2,
}

func (x ErrorCode_Code) String() string {
	return proto.EnumName(ErrorCode_Code_name, int32(x))
}
func (ErrorCode_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type RegisterRequest struct {
	// / User mail
	Email string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
	// / Certificate request (CSR) as PEM
	Request string `protobuf:"bytes,2,opt,name=request" json:"request,omitempty"`
}

func (m *RegisterRequest) Reset()                    { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string            { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()               {}
func (*RegisterRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// / ErrorCode message contains an error code and a message.
//
// Above or zero : target-side error
//
// Less than 0   : local error
type ErrorCode struct {
	Code ErrorCode_Code `protobuf:"varint,1,opt,name=code,enum=api.ErrorCode_Code" json:"code,omitempty"`
	// / An additional message, if needed
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *ErrorCode) Reset()                    { *m = ErrorCode{} }
func (m *ErrorCode) String() string            { return proto.CompactTextString(m) }
func (*ErrorCode) ProtoMessage()               {}
func (*ErrorCode) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type AuthRequest struct {
	// / User email
	Email string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
	// / User authentication token
	Token string `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *AuthRequest) Reset()                    { *m = AuthRequest{} }
func (m *AuthRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()               {}
func (*AuthRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type RegisteredUser struct {
	// / User certificate, as generated by the platform (PEM)
	ClientCert string `protobuf:"bytes,1,opt,name=clientCert" json:"clientCert,omitempty"`
}

func (m *RegisteredUser) Reset()                    { *m = RegisteredUser{} }
func (m *RegisteredUser) String() string            { return proto.CompactTextString(m) }
func (*RegisteredUser) ProtoMessage()               {}
func (*RegisteredUser) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// / An empty message, used when no parameters are required for a query or an answer.
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type PostContractRequest struct {
	// / Contract SHA-512 hash
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// / Contract filename
	Filename string `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	// / List of signers emails
	Signer []string `protobuf:"bytes,3,rep,name=signer" json:"signer,omitempty"`
	// / Additional comment
	Comment string `protobuf:"bytes,4,opt,name=comment" json:"comment,omitempty"`
}

func (m *PostContractRequest) Reset()                    { *m = PostContractRequest{} }
func (m *PostContractRequest) String() string            { return proto.CompactTextString(m) }
func (*PostContractRequest) ProtoMessage()               {}
func (*PostContractRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type GetContractRequest struct {
	// / UUID of the requested contract
	Uuid string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
}

func (m *GetContractRequest) Reset()                    { *m = GetContractRequest{} }
func (m *GetContractRequest) String() string            { return proto.CompactTextString(m) }
func (*GetContractRequest) ProtoMessage()               {}
func (*GetContractRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// / The fetched contract when using GetContract
type Contract struct {
	// / The result code
	ErrorCode *ErrorCode `protobuf:"bytes,1,opt,name=errorCode" json:"errorCode,omitempty"`
	// / The JSON object of the contract, equivalent to the one that was sent by mail to signers
	Json []byte `protobuf:"bytes,2,opt,name=json,proto3" json:"json,omitempty"`
}

func (m *Contract) Reset()                    { *m = Contract{} }
func (m *Contract) String() string            { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()               {}
func (*Contract) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Contract) GetErrorCode() *ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return nil
}

type JoinSignatureRequest struct {
	// / The contract UUID to join
	ContractUuid string `protobuf:"bytes,1,opt,name=contractUuid" json:"contractUuid,omitempty"`
	// / The open port for P2P communication of the client
	Port uint32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
	// / The offered ips for P2P communication of the client
	Ip []string `protobuf:"bytes,3,rep,name=ip" json:"ip,omitempty"`
}

func (m *JoinSignatureRequest) Reset()                    { *m = JoinSignatureRequest{} }
func (m *JoinSignatureRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinSignatureRequest) ProtoMessage()               {}
func (*JoinSignatureRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// / UserConnected is emitted by the platform to the client to announce a new client connection, through a stream.
// Previously connected clients are also emitted one by one just after the beginning of the stream.
type UserConnected struct {
	// / The result code.
	// Very bad if not equals to SUCCESS, in this case the client should close the connection
	ErrorCode *ErrorCode `protobuf:"bytes,1,opt,name=errorCode" json:"errorCode,omitempty"`
	// / A confirmation about the contract UUID
	ContractUuid string `protobuf:"bytes,2,opt,name=contractUuid" json:"contractUuid,omitempty"`
	// / One user connecting to this contract's room
	User *User `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
}

func (m *UserConnected) Reset()                    { *m = UserConnected{} }
func (m *UserConnected) String() string            { return proto.CompactTextString(m) }
func (*UserConnected) ProtoMessage()               {}
func (*UserConnected) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UserConnected) GetErrorCode() *ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return nil
}

func (m *UserConnected) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type User struct {
	// / The certificate hash of the user
	KeyHash []byte `protobuf:"bytes,1,opt,name=keyHash,proto3" json:"keyHash,omitempty"`
	Email   string `protobuf:"bytes,2,opt,name=email" json:"email,omitempty"`
	// / The IP offered by the user for P2P
	Ip []string `protobuf:"bytes,3,rep,name=ip" json:"ip,omitempty"`
	// / The port offered by the user for P2P
	Port uint32 `protobuf:"varint,4,opt,name=port" json:"port,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type ReadySignRequest struct {
	// / The contract UUID to be ready for
	ContractUuid string `protobuf:"bytes,1,opt,name=contractUuid" json:"contractUuid,omitempty"`
}

func (m *ReadySignRequest) Reset()                    { *m = ReadySignRequest{} }
func (m *ReadySignRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadySignRequest) ProtoMessage()               {}
func (*ReadySignRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// / LaunchSignature is emitted by the platform when every signers of a specific contract are ready.
type LaunchSignature struct {
	// / The result code
	ErrorCode *ErrorCode `protobuf:"bytes,1,opt,name=errorCode" json:"errorCode,omitempty"`
	// / The unique signature generated by the platform for this specific signature attempt
	SignatureUuid string `protobuf:"bytes,2,opt,name=signatureUuid" json:"signatureUuid,omitempty"`
	// / The SHA-512 hash of the contract document
	DocumentHash []byte `protobuf:"bytes,3,opt,name=documentHash,proto3" json:"documentHash,omitempty"`
	// / A confirmation of client hashes for communication authentication
	KeyHash [][]byte `protobuf:"bytes,4,rep,name=keyHash,proto3" json:"keyHash,omitempty"`
	// / The signing sequence generated on-the-fly by the platform
	Sequence []uint32 `protobuf:"varint,5,rep,name=sequence" json:"sequence,omitempty"`
	// / The ttp can be nil if no ttp is available for this signature
	Ttp *LaunchSignature_TTP `protobuf:"bytes,6,opt,name=ttp" json:"ttp,omitempty"`
	// / The cryptographic object of the signature of this structure (seal and errorCode excepted) by the platform, for data certification.
	// / The signature is computed using auth.SignStructure function:
	// / PKCS1v15 + SHA512 hash of the string representation of the structure
	Seal []byte `protobuf:"bytes,10,opt,name=seal,proto3" json:"seal,omitempty"`
}

func (m *LaunchSignature) Reset()                    { *m = LaunchSignature{} }
func (m *LaunchSignature) String() string            { return proto.CompactTextString(m) }
func (*LaunchSignature) ProtoMessage()               {}
func (*LaunchSignature) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *LaunchSignature) GetErrorCode() *ErrorCode {
	if m != nil {
		return m.ErrorCode
	}
	return nil
}

func (m *LaunchSignature) GetTtp() *LaunchSignature_TTP {
	if m != nil {
		return m.Ttp
	}
	return nil
}

// / TTP is the ttp associated to this signature, that should be contacted in case of error
type LaunchSignature_TTP struct {
	Addrport string `protobuf:"bytes,1,opt,name=addrport" json:"addrport,omitempty"`
	Hash     []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *LaunchSignature_TTP) Reset()                    { *m = LaunchSignature_TTP{} }
func (m *LaunchSignature_TTP) String() string            { return proto.CompactTextString(m) }
func (*LaunchSignature_TTP) ProtoMessage()               {}
func (*LaunchSignature_TTP) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12, 0} }

func init() {
	proto.RegisterType((*RegisterRequest)(nil), "api.RegisterRequest")
	proto.RegisterType((*ErrorCode)(nil), "api.ErrorCode")
	proto.RegisterType((*AuthRequest)(nil), "api.AuthRequest")
	proto.RegisterType((*RegisteredUser)(nil), "api.RegisteredUser")
	proto.RegisterType((*Empty)(nil), "api.Empty")
	proto.RegisterType((*PostContractRequest)(nil), "api.PostContractRequest")
	proto.RegisterType((*GetContractRequest)(nil), "api.GetContractRequest")
	proto.RegisterType((*Contract)(nil), "api.Contract")
	proto.RegisterType((*JoinSignatureRequest)(nil), "api.JoinSignatureRequest")
	proto.RegisterType((*UserConnected)(nil), "api.UserConnected")
	proto.RegisterType((*User)(nil), "api.User")
	proto.RegisterType((*ReadySignRequest)(nil), "api.ReadySignRequest")
	proto.RegisterType((*LaunchSignature)(nil), "api.LaunchSignature")
	proto.RegisterType((*LaunchSignature_TTP)(nil), "api.LaunchSignature.TTP")
	proto.RegisterEnum("api.ErrorCode_Code", ErrorCode_Code_name, ErrorCode_Code_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for Platform service

type PlatformClient interface {
	// / Register a new user, no authentication required.
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*ErrorCode, error)
	// / Authenticate a previously registered user, no authentication required.
	Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*RegisteredUser, error)
	// / Unregister a new user, authentication required.
	Unregister(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrorCode, error)
	// / Create a new contract, authentication required.
	PostContract(ctx context.Context, in *PostContractRequest, opts ...grpc.CallOption) (*ErrorCode, error)
	// / Fetch a previously create contract, authentication required.
	GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*Contract, error)
	// / Join a signature discovery room, authentication required.
	// The stream is triggered for each new user connected in this channel.
	JoinSignature(ctx context.Context, in *JoinSignatureRequest, opts ...grpc.CallOption) (Platform_JoinSignatureClient, error)
	// / Join an ignition room, authentication required.
	// The response is returned when every signer is ready for a specific contract.
	// Warning, can me answered with a very high delay.
	ReadySign(ctx context.Context, in *ReadySignRequest, opts ...grpc.CallOption) (*LaunchSignature, error)
}

type platformClient struct {
	cc *grpc.ClientConn
}

func NewPlatformClient(cc *grpc.ClientConn) PlatformClient {
	return &platformClient{cc}
}

func (c *platformClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*ErrorCode, error) {
	out := new(ErrorCode)
	err := grpc.Invoke(ctx, "/api.Platform/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Auth(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*RegisteredUser, error) {
	out := new(RegisteredUser)
	err := grpc.Invoke(ctx, "/api.Platform/Auth", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) Unregister(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ErrorCode, error) {
	out := new(ErrorCode)
	err := grpc.Invoke(ctx, "/api.Platform/Unregister", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) PostContract(ctx context.Context, in *PostContractRequest, opts ...grpc.CallOption) (*ErrorCode, error) {
	out := new(ErrorCode)
	err := grpc.Invoke(ctx, "/api.Platform/PostContract", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) GetContract(ctx context.Context, in *GetContractRequest, opts ...grpc.CallOption) (*Contract, error) {
	out := new(Contract)
	err := grpc.Invoke(ctx, "/api.Platform/GetContract", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *platformClient) JoinSignature(ctx context.Context, in *JoinSignatureRequest, opts ...grpc.CallOption) (Platform_JoinSignatureClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Platform_serviceDesc.Streams[0], c.cc, "/api.Platform/JoinSignature", opts...)
	if err != nil {
		return nil, err
	}
	x := &platformJoinSignatureClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Platform_JoinSignatureClient interface {
	Recv() (*UserConnected, error)
	grpc.ClientStream
}

type platformJoinSignatureClient struct {
	grpc.ClientStream
}

func (x *platformJoinSignatureClient) Recv() (*UserConnected, error) {
	m := new(UserConnected)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *platformClient) ReadySign(ctx context.Context, in *ReadySignRequest, opts ...grpc.CallOption) (*LaunchSignature, error) {
	out := new(LaunchSignature)
	err := grpc.Invoke(ctx, "/api.Platform/ReadySign", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Platform service

type PlatformServer interface {
	// / Register a new user, no authentication required.
	Register(context.Context, *RegisterRequest) (*ErrorCode, error)
	// / Authenticate a previously registered user, no authentication required.
	Auth(context.Context, *AuthRequest) (*RegisteredUser, error)
	// / Unregister a new user, authentication required.
	Unregister(context.Context, *Empty) (*ErrorCode, error)
	// / Create a new contract, authentication required.
	PostContract(context.Context, *PostContractRequest) (*ErrorCode, error)
	// / Fetch a previously create contract, authentication required.
	GetContract(context.Context, *GetContractRequest) (*Contract, error)
	// / Join a signature discovery room, authentication required.
	// The stream is triggered for each new user connected in this channel.
	JoinSignature(*JoinSignatureRequest, Platform_JoinSignatureServer) error
	// / Join an ignition room, authentication required.
	// The response is returned when every signer is ready for a specific contract.
	// Warning, can me answered with a very high delay.
	ReadySign(context.Context, *ReadySignRequest) (*LaunchSignature, error)
}

func RegisterPlatformServer(s *grpc.Server, srv PlatformServer) {
	s.RegisterService(&_Platform_serviceDesc, srv)
}

func _Platform_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Platform/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Platform/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Auth(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_Unregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).Unregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Platform/Unregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).Unregister(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_PostContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PostContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).PostContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Platform/PostContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).PostContract(ctx, req.(*PostContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_GetContract_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetContractRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).GetContract(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Platform/GetContract",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).GetContract(ctx, req.(*GetContractRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Platform_JoinSignature_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JoinSignatureRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(PlatformServer).JoinSignature(m, &platformJoinSignatureServer{stream})
}

type Platform_JoinSignatureServer interface {
	Send(*UserConnected) error
	grpc.ServerStream
}

type platformJoinSignatureServer struct {
	grpc.ServerStream
}

func (x *platformJoinSignatureServer) Send(m *UserConnected) error {
	return x.ServerStream.SendMsg(m)
}

func _Platform_ReadySign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadySignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PlatformServer).ReadySign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Platform/ReadySign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PlatformServer).ReadySign(ctx, req.(*ReadySignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Platform_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Platform",
	HandlerType: (*PlatformServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Platform_Register_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Platform_Auth_Handler,
		},
		{
			MethodName: "Unregister",
			Handler:    _Platform_Unregister_Handler,
		},
		{
			MethodName: "PostContract",
			Handler:    _Platform_PostContract_Handler,
		},
		{
			MethodName: "GetContract",
			Handler:    _Platform_GetContract_Handler,
		},
		{
			MethodName: "ReadySign",
			Handler:    _Platform_ReadySign_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "JoinSignature",
			Handler:       _Platform_JoinSignature_Handler,
			ServerStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 768 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0xd3, 0x4a,
	0x10, 0x4e, 0x62, 0x37, 0x3f, 0x93, 0x26, 0xb5, 0x36, 0x39, 0xe7, 0xf8, 0x44, 0xea, 0x51, 0xb5,
	0x3a, 0x12, 0x55, 0x85, 0x92, 0x2a, 0x08, 0x10, 0xdc, 0xa5, 0x21, 0x6a, 0x8b, 0x4a, 0xa9, 0x36,
	0x09, 0x48, 0x5c, 0x20, 0x19, 0x7b, 0xdb, 0x98, 0x26, 0xb6, 0xd9, 0xdd, 0x08, 0xf5, 0x8e, 0x47,
	0xe0, 0x61, 0x10, 0x8f, 0x07, 0xec, 0xae, 0x7f, 0xe2, 0x84, 0x08, 0xa9, 0xbd, 0x70, 0x77, 0x7e,
	0x76, 0xe6, 0x9b, 0x6f, 0x67, 0x26, 0xb0, 0xef, 0x5d, 0x73, 0xde, 0x53, 0x9f, 0xa8, 0xe7, 0x44,
	0x7e, 0x2f, 0x9a, 0x3b, 0xe2, 0x3a, 0x64, 0x8b, 0x6e, 0xc4, 0x42, 0x11, 0x22, 0x43, 0xea, 0xf0,
	0x00, 0xf6, 0x08, 0xbd, 0xf1, 0xb9, 0xa0, 0x8c, 0xd0, 0x4f, 0x4b, 0xca, 0x05, 0x6a, 0xc3, 0x0e,
	0x5d, 0x38, 0xfe, 0xdc, 0x2e, 0x1e, 0x14, 0x0f, 0x6b, 0x24, 0x16, 0x90, 0x0d, 0x15, 0x16, 0x3b,
	0xd8, 0x25, 0xad, 0x4f, 0x45, 0xfc, 0xad, 0x08, 0xb5, 0x11, 0x63, 0x21, 0x1b, 0x86, 0x1e, 0x45,
	0x0f, 0xc0, 0x74, 0xe5, 0x7f, 0x7d, 0xb9, 0xd9, 0x6f, 0x75, 0x65, 0x92, 0x6e, 0x66, 0xed, 0xaa,
	0x0f, 0xd1, 0x0e, 0x2a, 0xe0, 0x82, 0x72, 0xee, 0xdc, 0xd0, 0x34, 0x60, 0x22, 0x62, 0x0f, 0x4c,
	0x1d, 0xaa, 0x0e, 0x95, 0xf1, 0x74, 0x38, 0x1c, 0x8d, 0xc7, 0x56, 0x01, 0x01, 0x94, 0xcf, 0x2f,
	0xdf, 0x0c, 0xc8, 0xa9, 0x55, 0x54, 0x86, 0x93, 0xc1, 0x8b, 0xc1, 0x74, 0x72, 0x66, 0x95, 0x94,
	0xf0, 0x76, 0x40, 0x2e, 0xcf, 0x2f, 0x4f, 0x2d, 0x03, 0xb5, 0x94, 0xd7, 0x64, 0x44, 0x88, 0xf5,
	0x33, 0xfd, 0x2b, 0xca, 0x82, 0x2a, 0x93, 0xf3, 0x57, 0xa3, 0xd7, 0xd3, 0x89, 0xf5, 0x23, 0xd3,
	0xe2, 0x67, 0x50, 0x1f, 0x2c, 0xc5, 0xec, 0xcf, 0x55, 0x4b, 0xad, 0x08, 0x6f, 0x69, 0x90, 0x40,
	0x8c, 0x05, 0x7c, 0x0c, 0xcd, 0x94, 0x34, 0xea, 0x4d, 0x39, 0x65, 0xe8, 0x3f, 0x00, 0x77, 0xee,
	0xd3, 0x40, 0x0c, 0x29, 0x13, 0x49, 0x88, 0x9c, 0x06, 0x57, 0x60, 0x67, 0xb4, 0x88, 0xc4, 0x1d,
	0xfe, 0x0c, 0xad, 0xab, 0x90, 0x8b, 0x61, 0x18, 0x08, 0xe6, 0xb8, 0x22, 0xcd, 0x8e, 0xc0, 0x9c,
	0x39, 0x7c, 0xa6, 0x6f, 0xee, 0x12, 0x7d, 0x46, 0x1d, 0xa8, 0x5e, 0xfb, 0x73, 0x1a, 0x38, 0x8b,
	0x94, 0xa1, 0x4c, 0x46, 0x7f, 0x43, 0x99, 0xfb, 0x37, 0x01, 0x65, 0xb6, 0x71, 0x60, 0x48, 0x4b,
	0x22, 0x29, 0x52, 0xdd, 0x70, 0xb1, 0x90, 0x69, 0x6d, 0x33, 0x26, 0x35, 0x11, 0xf1, 0x21, 0xa0,
	0x53, 0xba, 0x2d, 0xef, 0x72, 0xe9, 0x7b, 0x09, 0x62, 0x7d, 0xc6, 0x17, 0x50, 0x4d, 0xdd, 0xd0,
	0x43, 0xa8, 0xd1, 0xf4, 0xf1, 0xb4, 0x53, 0xbd, 0xdf, 0x5c, 0x7f, 0x52, 0xb2, 0x72, 0x50, 0xd1,
	0x3e, 0xf2, 0x30, 0x26, 0x4b, 0x56, 0xa1, 0xce, 0xf8, 0x3d, 0xb4, 0x5f, 0x86, 0x7e, 0x30, 0x96,
	0xf8, 0x1c, 0xb1, 0x64, 0x34, 0xcd, 0x8c, 0x61, 0xd7, 0x4d, 0xb2, 0x4c, 0x57, 0x08, 0xd6, 0x74,
	0x2a, 0x5e, 0x14, 0xb2, 0xb8, 0xe1, 0x1a, 0x44, 0x9f, 0x51, 0x13, 0x4a, 0x7e, 0x94, 0x54, 0x2d,
	0x4f, 0xf8, 0x4b, 0x11, 0x1a, 0xea, 0x09, 0x24, 0xe4, 0x80, 0xba, 0x82, 0x7a, 0xf7, 0xc4, 0xbc,
	0x89, 0xa3, 0xb4, 0x05, 0xc7, 0xbe, 0x64, 0x89, 0x6b, 0xae, 0x55, 0xb0, 0x9a, 0x0e, 0xa6, 0x72,
	0x12, 0xad, 0xc6, 0xef, 0xc0, 0xd4, 0x4d, 0x20, 0xc9, 0xbf, 0xa5, 0x77, 0x67, 0xab, 0x77, 0x4c,
	0xc5, 0x55, 0x73, 0x95, 0xf2, 0xcd, 0xb5, 0x51, 0x4a, 0x56, 0xae, 0xb9, 0x2a, 0x17, 0x3f, 0x01,
	0x8b, 0x50, 0xc7, 0xbb, 0x53, 0xfc, 0xdd, 0x83, 0x3a, 0xfc, 0xbd, 0x04, 0x7b, 0x17, 0xce, 0x32,
	0x70, 0x67, 0x19, 0xf3, 0xf7, 0x24, 0xe6, 0x7f, 0x68, 0xf0, 0xf4, 0x6a, 0x8e, 0x99, 0x75, 0xa5,
	0xc2, 0xe2, 0x85, 0xee, 0x52, 0xb5, 0x98, 0x2e, 0xdc, 0xd0, 0x85, 0xaf, 0xe9, 0xf2, 0xbc, 0x98,
	0xb2, 0xd8, 0x1c, 0x2f, 0xb2, 0xc5, 0xb9, 0x2a, 0x2a, 0x70, 0xa9, 0xbd, 0x23, 0x4d, 0x0d, 0x92,
	0xc9, 0xe8, 0x08, 0x0c, 0x21, 0x22, 0xbb, 0xac, 0x71, 0xda, 0x1a, 0xe7, 0x46, 0x41, 0xdd, 0xc9,
	0xe4, 0x8a, 0x28, 0x27, 0xc5, 0x1c, 0xa7, 0xce, 0xdc, 0x86, 0xb8, 0xf1, 0xd4, 0xb9, 0xf3, 0x18,
	0x0c, 0x69, 0x57, 0x29, 0x1c, 0xcf, 0x63, 0x9a, 0xd8, 0x98, 0xa8, 0x4c, 0xce, 0xa6, 0xae, 0xb4,
	0x9a, 0xba, 0xfe, 0x57, 0x03, 0xaa, 0x57, 0xc9, 0xa2, 0x44, 0x7d, 0xa8, 0xa6, 0x83, 0x8e, 0xda,
	0x1a, 0xc2, 0xc6, 0xb2, 0xec, 0x6c, 0x10, 0x88, 0x0b, 0xa8, 0x07, 0xa6, 0xda, 0x2b, 0xc8, 0xd2,
	0x96, 0xdc, 0x8a, 0xe9, 0xb4, 0xd6, 0x22, 0xc4, 0x9b, 0x43, 0x5e, 0x38, 0x02, 0x98, 0x06, 0x2c,
	0x4d, 0x03, 0x71, 0x40, 0xb5, 0x2c, 0xb6, 0x04, 0x7f, 0x0e, 0xbb, 0xf9, 0xf5, 0x81, 0x62, 0x5e,
	0xb6, 0x6c, 0x94, 0x2d, 0x77, 0x9f, 0x42, 0x3d, 0xb7, 0x01, 0xd0, 0x3f, 0xda, 0xe1, 0xf7, 0x9d,
	0xd0, 0x69, 0x68, 0x43, 0xaa, 0x95, 0x17, 0x4f, 0xa0, 0xb1, 0x36, 0xc2, 0xe8, 0x5f, 0xed, 0xb1,
	0x6d, 0xac, 0x3b, 0x28, 0x1b, 0x8e, 0x6c, 0x20, 0x71, 0xe1, 0xb8, 0x28, 0x81, 0xd7, 0xb2, 0x3e,
	0x46, 0x7f, 0x25, 0x44, 0xac, 0xf7, 0x75, 0xa7, 0xbd, 0xed, 0x91, 0x71, 0xe1, 0x43, 0x59, 0xff,
	0x5e, 0x3d, 0xfa, 0x15, 0x00, 0x00, 0xff, 0xff, 0x31, 0x18, 0xb6, 0x50, 0xd0, 0x06, 0x00, 0x00,
}
